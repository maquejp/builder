/**
 * Oracle Service for handling Oracle database specific operations
 * Author: Jean-Philippe Maquestiaux
 * License: EUPL-1.2
 */

import chalk from "chalk";
import {
  DatabaseConfiguration,
  DatabaseTable,
  DatabaseField,
} from "../../interfaces";
import { DatabaseHelper } from "./DatabaseHelper";
import { FileHelper } from "../../helpers";

export class OracleService {
  /**
   * Execute Oracle database operations
   * @param config Database configuration from project definition
   * @param projectFolder The project folder name from the project definition
   */
  public async execute(
    config: DatabaseConfiguration,
    projectFolder: string
  ): Promise<void> {
    console.log(
      chalk.blue("ðŸ”§ Oracle Service: Starting Oracle database operations...")
    );

    // Display tables information
    DatabaseHelper.showTables(config.tables);

    // Sort tables based on dependencies (referenced tables first)
    const sortedTables = DatabaseHelper.sortTablesByDependencies(config.tables);

    // Ensure the database directories exist
    await FileHelper.ensureDatabaseDir(projectFolder, "tables");
    await FileHelper.ensureDatabaseDir(projectFolder, "triggers");

    // Process each table
    for (let i = 0; i < sortedTables.length; i++) {
      const table = sortedTables[i];
      const tableScript = await this.createTable(table);

      // Save the table script to file using FileHelper with order number
      await FileHelper.saveDatabaseScript({
        projectFolder,
        scriptType: "tables",
        fileName: table.name,
        content: tableScript,
        order: i + 1, // Start from 1 instead of 0
      });

      await this.populateTable(table);
      await this.createTrigger(table, projectFolder);
      await this.createView(table);
      await this.createCrudPackage(table);
    }

    console.log(
      chalk.green("âœ… Oracle Service: Operations completed successfully")
    );
  }

  private async createTable(table: DatabaseTable): Promise<string> {
    console.log(chalk.blue(`ðŸ”§ Oracle Service: Creating table ${table.name}`));

    // Generate CREATE TABLE statement
    const tableName = table.name.toUpperCase();
    let script = `-- Table: ${tableName}\n`;
    script += `-- Generated by Stackcraft Oracle Service\n`;
    script += `-- Author: Jean-Philippe Maquestiaux\n`;
    script += `-- License: EUPL-1.2\n\n`;

    script += `CREATE TABLE ${tableName} (\n`;

    // Process each field
    const fieldDefinitions = table.fields.map((field, index) => {
      const fieldName = field.name.toUpperCase();
      const fieldType = field.type.toUpperCase();

      // Build field definition
      let fieldDef = `    ${fieldName} ${fieldType}`;

      // Add nullable constraint (only for NOT NULL, as NULL is default in Oracle)
      if (field.nullable === false) {
        fieldDef += " NOT NULL";
      }

      // Add default value if specified
      if (field.default) {
        // Handle special Oracle keywords and string literals
        const defaultValue =
          field.default.toLowerCase() === "systimestamp"
            ? "SYSTIMESTAMP"
            : field.default.startsWith("'") && field.default.endsWith("'")
            ? field.default
            : `'${field.default}'`;
        fieldDef += ` DEFAULT ${defaultValue}`;
      }

      return fieldDef;
    });

    // Join field definitions
    script += fieldDefinitions.join(",\n");
    script += "\n);";

    // Add comments for table and fields
    const comments: string[] = [];

    // Add field comments
    table.fields.forEach((field) => {
      if (field.comment) {
        const fieldName = field.name.toUpperCase();
        comments.push(
          `COMMENT ON COLUMN ${tableName}.${fieldName} IS '${field.comment}';`
        );
      }
    });

    if (comments.length > 0) {
      script += "\n\n-- Field comments\n";
      script += comments.join("\n");
    }

    // Add constraints to the same script
    const constraintsScript = await this.createConstrains(table);
    if (constraintsScript) {
      script += "\n\n" + constraintsScript;
    }

    await this.delay(500);

    return script;
  }

  // TODO: Create relationships: foreign keys, unique constraints... (for each table)

  private async createConstrains(table: DatabaseTable): Promise<string | null> {
    const tableName = table.name.toUpperCase();
    const constraints: string[] = [];

    // 1. Create Primary Key Constraints
    const primaryKeyFields = table.fields.filter((field) => field.isPrimaryKey);
    if (primaryKeyFields.length > 0) {
      const pkColumns = primaryKeyFields
        .map((field) => field.name.toUpperCase())
        .join(", ");
      const pkConstraintName = `${tableName}_PK`;
      constraints.push(
        `-- Primary Key Constraint\nALTER TABLE ${tableName} ADD CONSTRAINT ${pkConstraintName} PRIMARY KEY (${pkColumns});`
      );
    }

    // 2. Create Foreign Key Constraints
    const foreignKeyFields = table.fields.filter(
      (field) => field.isForeignKey && field.foreignKey
    );
    for (const field of foreignKeyFields) {
      const fieldName = field.name.toUpperCase();
      const referencedTable = field.foreignKey!.referencedTable.toUpperCase();
      const referencedColumn = field.foreignKey!.referencedColumn.toUpperCase();
      const fkConstraintName = `${tableName}_${referencedTable}_FK`;

      constraints.push(
        `-- Foreign Key Constraint for ${fieldName}\nALTER TABLE ${tableName} ADD CONSTRAINT ${fkConstraintName} FOREIGN KEY (${fieldName}) REFERENCES ${referencedTable}(${referencedColumn});`
      );
    }

    // 3. Create Unique Constraints
    const uniqueFields = table.fields.filter((field) => field.unique);
    for (const field of uniqueFields) {
      const fieldName = field.name.toUpperCase();
      const uniqueConstraintName = `${tableName}_${fieldName}_UK`;
      constraints.push(
        `-- Unique Constraint for ${fieldName}\nALTER TABLE ${tableName} ADD CONSTRAINT ${uniqueConstraintName} UNIQUE (${fieldName});`
      );
    }

    // 4. Create Check Constraints for allowed values
    const fieldsWithAllowedValues = table.fields.filter(
      (field) => field.allowedValues && field.allowedValues.length > 0
    );
    for (const field of fieldsWithAllowedValues) {
      const fieldName = field.name.toUpperCase();
      const checkConstraintName = `${tableName}_${fieldName}_CK`;

      // Build the check condition with proper quoting for string values
      const allowedValues = field
        .allowedValues!.map((value) => {
          return typeof value === "string" ? `'${value}'` : value.toString();
        })
        .join(", ");

      constraints.push(
        `-- Check Constraint for ${fieldName}\nALTER TABLE ${tableName} ADD CONSTRAINT ${checkConstraintName} CHECK (${fieldName} IN (${allowedValues}));`
      );
    }

    // Return constraints script if there are any constraints to create
    if (constraints.length > 0) {
      return [`-- Table Constraints`, ...constraints].join("\n");
    }

    return null;
  }

  // TODO: Insert initial data (for each table)

  private async populateTable(table: DatabaseTable): Promise<void> {
    console.log(
      chalk.blue(
        `ðŸ”§ Oracle Service: Inserting initial data for table ${table.name}`
      )
    );
    // Placeholder for data population logic
    await this.delay(500);
  }

  // Create Triggers (for each table)

  private async createTrigger(
    table: DatabaseTable,
    projectFolder?: string
  ): Promise<void> {
    console.log(
      chalk.blue(`ðŸ”§ Oracle Service: Creating trigger for table ${table.name}`)
    );

    // Find fields that have triggers enabled
    const fieldsWithTriggers = table.fields.filter(
      (field) => field.trigger?.enabled === true
    );

    if (fieldsWithTriggers.length === 0) {
      console.log(chalk.gray(`   No triggers defined for table ${table.name}`));
      await this.delay(200);
      return;
    }

    // Group fields by trigger event type to create combined triggers when possible
    const triggerGroups = new Map<string, DatabaseField[]>();

    fieldsWithTriggers.forEach((field) => {
      const event = field.trigger?.event || "before_update";
      const condition = field.trigger?.condition || "";
      const key = `${event}_${condition}`; // Group by event and condition

      if (!triggerGroups.has(key)) {
        triggerGroups.set(key, []);
      }
      triggerGroups.get(key)!.push(field);
    });

    // Generate triggers for each group
    let triggerIndex = 1;
    for (const [key, fields] of triggerGroups) {
      const triggerScript = await this.generateTriggerScript(table, fields);

      if (triggerScript) {
        // Save the trigger script to file
        const [event, timing] = key.split("_", 2);
        const hasCondition = key.includes("WHEN");
        const suffix = hasCondition ? "conditional" : timing || "trigger";
        const triggerFileName = `${table.name}_${event}_${suffix}`;

        await FileHelper.saveDatabaseScript({
          projectFolder: projectFolder || "default-project",
          scriptType: "triggers",
          fileName: triggerFileName,
          content: triggerScript,
          order: triggerIndex++,
        });
      }
    }

    await this.delay(500);
  }

  private async generateTriggerScript(
    table: DatabaseTable,
    fields: DatabaseField[]
  ): Promise<string | null> {
    if (fields.length === 0) return null;

    const tableName = table.name.toUpperCase();
    const firstField = fields[0];
    const event = firstField.trigger?.event || "before_update";
    const condition = firstField.trigger?.condition;

    // Parse event type for Oracle syntax
    const eventParts = event.split("_");
    const timing = eventParts[0].toUpperCase(); // BEFORE or AFTER
    const operations = eventParts
      .slice(1)
      .map((op: string) => op.toUpperCase())
      .join(" OR "); // INSERT, UPDATE, or INSERT OR UPDATE

    // Generate unique trigger name based on fields and condition
    const fieldsHash = fields
      .map((f) => f.name)
      .join("_")
      .substring(0, 10);
    const conditionHash = condition ? "COND" : "";
    const triggerName = `${tableName}_${timing.substring(
      0,
      2
    )}_${operations.replace(" OR ", "_")}_${fieldsHash}_${conditionHash}_TRG`;

    let script = `-- Trigger: ${triggerName}\n`;
    script += `-- Generated by Stackcraft Oracle Service\n`;
    script += `-- Automatically updates: ${fields
      .map((f) => f.name)
      .join(", ")}\n`;
    script += `-- Author: Jean-Philippe Maquestiaux\n`;
    script += `-- License: EUPL-1.2\n\n`;

    script += `CREATE OR REPLACE TRIGGER ${triggerName}\n`;
    script += `    ${timing} ${operations} ON ${tableName}\n`;
    script += `    FOR EACH ROW\n`;

    // Add condition if specified
    if (condition) {
      script += `    ${condition}\n`;
    }

    script += `BEGIN\n`;

    // Generate trigger body for each field
    fields.forEach((field) => {
      const fieldName = field.name.toUpperCase();
      const action = field.trigger?.action || "systimestamp";

      script += `    -- Auto-update ${fieldName}\n`;

      // Handle different action types
      if (action.toLowerCase() === "systimestamp") {
        script += `    :NEW.${fieldName} := SYSTIMESTAMP;\n`;
      } else if (action.toLowerCase() === "user") {
        script += `    :NEW.${fieldName} := USER;\n`;
      } else if (action.toLowerCase() === "sysdate") {
        script += `    :NEW.${fieldName} := SYSDATE;\n`;
      } else if (action.startsWith("'") && action.endsWith("'")) {
        // String literal
        script += `    :NEW.${fieldName} := ${action};\n`;
      } else if (/^\d+(\.\d+)?$/.test(action)) {
        // Numeric literal
        script += `    :NEW.${fieldName} := ${action};\n`;
      } else {
        // Custom PL/SQL expression or function call
        script += `    :NEW.${fieldName} := ${action};\n`;
      }

      script += `\n`;
    });

    script += `END ${triggerName};\n`;
    script += `/\n`; // Oracle SQL*Plus terminator

    return script;
  }

  // TODO: Create Views (for each table)

  private async createView(table: DatabaseTable): Promise<void> {
    console.log(
      chalk.blue(`ðŸ”§ Oracle Service: Creating view for table ${table.name}`)
    );
    // Placeholder for view creation logic
    await this.delay(500);
  }

  // TODO: Create CRUD Packages (for each table)

  private async createCrudPackage(table: DatabaseTable): Promise<void> {
    console.log(
      chalk.blue(
        `ðŸ”§ Oracle Service: Creating CRUD package for table ${table.name}`
      )
    );
    // Placeholder for CRUD package creation logic
    await this.delay(500);
  }

  /**
   * Utility method to simulate async work
   */
  private async delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
